generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id             String          @id @default(uuid())
  email          String          @unique
  password       String
  isActive       Boolean         @default(true)
  createdAt      DateTime        @default(now())
  updatedAt      DateTime        @updatedAt
  lastname       String
  name           String
  documents      Document[]
  studentProfile StudentProfile? @relation("UserStudentProfile")
  teacherProfile TeacherProfile? @relation("UserTeacherProfile")
  roles          UserRole[]
  sessions       UserSession[]
}

model Role {
  id          String           @id @default(uuid())
  name        String           @unique
  description String?
  createdAt   DateTime         @default(now())
  updatedAt   DateTime         @updatedAt
  permissions RolePermission[]
  users       UserRole[]
}

model Permission {
  id          String           @id @default(uuid())
  action      String
  resource    String
  description String?
  roles       RolePermission[]

  @@unique([action, resource], map: "action_resource")
}

model UserRole {
  userId String
  roleId String
  role   Role   @relation(fields: [roleId], references: [id], onDelete: Cascade)
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([userId, roleId])
  @@index([roleId])
}

model RolePermission {
  roleId       String
  permissionId String
  permission   Permission @relation(fields: [permissionId], references: [id], onDelete: Cascade)
  role         Role       @relation(fields: [roleId], references: [id], onDelete: Cascade)

  @@id([roleId, permissionId])
}

model TeacherProfile {
  userId       String   @id
  academicUnit String?
  title        String?
  bio          String?
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  courses      Course[]
  user         User     @relation("UserTeacherProfile", fields: [userId], references: [id], onDelete: Cascade)
}

model StudentProfile {
  userId        String       @id
  code          String       @unique
  career        String?
  admissionYear Int?
  createdAt     DateTime     @default(now())
  updatedAt     DateTime     @updatedAt
  enrollment    Enrollment[]
  user          User         @relation("UserStudentProfile", fields: [userId], references: [id], onDelete: Cascade)
}

model UserSession {
  id            String   @id @default(uuid())
  userId        String
  token         String
  refresh_token String
  createdAt     DateTime @default(now())
  expiresAt     DateTime
  ipAddress     String?
  userAgent     String?
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, expiresAt])
}

model Document {
  id             String                    @id @default(uuid())
  originalName   String
  storedName     String                    @unique
  s3Key          String
  size           Int
  contentType    String
  uploadedAt     DateTime                  @default(now())
  documentAuthor String?
  documentTitle  String?
  extractedText  String?
  fileHash       String                    @unique
  language       String?
  pageCount      Int?
  status         DocumentStatus            @default(UPLOADED)
  updatedAt      DateTime                  @updatedAt
  uploadedBy     String
  uploader       User                      @relation(fields: [uploadedBy], references: [id])
  categories     DocumentCategoryMapping[]
  processingJobs ProcessingJob[]
  chunks         DocumentChunk[]

  @@index([status])
  @@index([uploadedBy])
  @@index([fileHash])
  @@index([contentType])
}

model DocumentChunk {
  id            String                 @id @default(uuid())
  documentId    String
  content       String
  chunkIndex    Int
  startPosition Int
  endPosition   Int
  pageNumber    Int?
  type          String                 @default("text")
  wordCount     Int                    @default(0)
  charCount     Int                    @default(0)
  embedding     Unsupported("vector")?
  metadata      Json?
  createdAt     DateTime               @default(now())
  updatedAt     DateTime               @updatedAt
  document      Document               @relation(fields: [documentId], references: [id], onDelete: Cascade)

  @@unique([documentId, chunkIndex])
  @@index([documentId])
  @@index([type])
  @@index([wordCount])
  @@map("document_chunks")
}

model DocumentCategory {
  id          String                    @id @default(uuid())
  name        String                    @unique
  description String?
  color       String?
  icon        String?
  createdAt   DateTime                  @default(now())
  updatedAt   DateTime                  @updatedAt
  documents   DocumentCategoryMapping[]
}

model DocumentCategoryMapping {
  documentId String
  categoryId String
  createdAt  DateTime         @default(now())
  category   DocumentCategory @relation(fields: [categoryId], references: [id], onDelete: Cascade)
  document   Document         @relation(fields: [documentId], references: [id], onDelete: Cascade)

  @@id([documentId, categoryId])
}

model ProcessingJob {
  id           String           @id @default(uuid())
  documentId   String
  jobType      ProcessingType
  status       ProcessingStatus @default(PENDING)
  errorMessage String?
  progress     Int              @default(0)
  jobDetails   Json?
  result       Json?
  startedAt    DateTime?
  completedAt  DateTime?
  createdAt    DateTime         @default(now())
  document     Document         @relation(fields: [documentId], references: [id], onDelete: Cascade)

  @@index([documentId, jobType])
  @@index([status])
  @@index([createdAt])
}

/**
 * ===========================
 * Enums para Document Processing
 * ===========================
 */

enum DocumentStatus {
  UPLOADED      // Archivo subido, esperando procesamiento
  PROCESSING    // En proceso de extracción/chunking/embedding
  PROCESSED     // Completamente procesado y listo para búsqueda
  ERROR         // Error en el procesamiento
  DELETED       // Marcado como eliminado
}

enum ProcessingType {
  TEXT_EXTRACTION       // Extraer texto del archivo
  CHUNKING             // Dividir texto en chunks
  EMBEDDING_GENERATION // Generar embeddings vectoriales
  FULL_PROCESSING      // Procesamiento completo (todos los pasos)
  REPROCESSING         // Reprocesar documento existente
}

enum ProcessingStatus {
  PENDING      // Esperando en cola
  RUNNING      // Ejecutándose actualmente
  COMPLETED    // Completado exitosamente
  FAILED       // Falló con error
  CANCELLED    // Cancelado manualmente
  RETRYING     // Reintentando después de fallo
}

enum ChunkType {
  TEXT         // Chunk de texto normal
  TITLE        // Título o encabezado
  TABLE        // Contenido de tabla
  LIST         // Lista o enumeración
  CODE         // Código o texto técnico
  FORMULA      // Fórmula matemática
  METADATA     // Metadatos del documento
}

/**
 * ===========================
 * Exams generation
 * ===========================
 */

model Exam {
  id                String         @id @default(uuid())
  subject           String
  difficulty        String
  attempts          Int
  totalQuestions    Int
  timeMinutes       Int
  reference         String?
  createdAt         DateTime       @default(now())
  mcqCount          Int            @default(0)
  openAnalysisCount Int            @default(0)
  openExerciseCount Int            @default(0)
  trueFalseCount    Int            @default(0)
  approvedAt        DateTime?
  updatedAt         DateTime       @updatedAt
  questions         ExamQuestion[]

  @@index([subject])
}

model ExamQuestion {
  id                 String       @id @default(cuid())
  examId             String
  kind               QuestionKind
  text               String
  options            Json?
  correctOptionIndex Int?
  correctBoolean     Boolean?
  expectedAnswer     String?
  order              Int
  createdAt          DateTime     @default(now())
  updatedAt          DateTime     @updatedAt
  exam               Exam         @relation(fields: [examId], references: [id], onDelete: Cascade)

  @@unique([examId, order])
  @@index([examId, order])
}

model Course {
  id        String         @id @default(uuid())
  name      String
  isActive  Boolean        @default(true)
  teacherId String
  createdAt DateTime       @default(now())
  updatedAt DateTime       @updatedAt
  classes   Classes[]
  teacher   TeacherProfile @relation(fields: [teacherId], references: [userId])
}

model Classes {
  id         String       @id @default(uuid())
  name       String
  semester   String
  isActive   Boolean      @default(true)
  dateBegin  DateTime
  dateEnd    DateTime
  courseId   String
  createdAt  DateTime     @default(now())
  updatedAt  DateTime     @default(now()) @updatedAt
  course     Course       @relation(fields: [courseId], references: [id])
  enrollment Enrollment[]
}

model Enrollment {
  studentId String
  classId   String
  isActive  Boolean        @default(true)
  createdAt DateTime       @default(now())
  updatedAt DateTime       @updatedAt
  class     Classes        @relation(fields: [classId], references: [id])
  student   StudentProfile @relation(fields: [studentId], references: [userId])

  @@id([studentId, classId])
}

enum DocumentStatus {
  UPLOADED
  PROCESSING
  PROCESSED
  ERROR
  DELETED
}

enum ProcessingType {
  TEXT_EXTRACTION
  CHUNKING
  EMBEDDING_GENERATION
  FULL_PROCESSING
  REPROCESSING
  CATEGORIZATION
}

enum ProcessingStatus {
  PENDING
  RUNNING
  COMPLETED
  FAILED
  CANCELLED
  RETRYING
}

enum ChunkType {
  TEXT
  TITLE
  TABLE
  LIST
  CODE
  FORMULA
  METADATA
}

enum QuestionKind {
  MULTIPLE_CHOICE
  TRUE_FALSE
  OPEN_ANALYSIS
  OPEN_EXERCISE
}
